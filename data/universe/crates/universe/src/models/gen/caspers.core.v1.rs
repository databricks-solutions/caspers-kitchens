// @generated
// This file is @generated by prost-build.
/// Physical locations where kitchens operate
///
/// Multiple kitchens are located within each site.
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Site {
    /// Unique identifier for the location
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Name of the location
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(double, tag = "3")]
    pub latitude: f64,
    #[prost(double, tag = "4")]
    pub longitude: f64,
}
impl ::prost::Name for Site {
    const NAME: &'static str = "Site";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.Site".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.Site".into()
    }
}
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SiteSetup {
    /// Base information about the site
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<Site>,
    /// Kitchens installed at the site
    #[prost(message, repeated, tag = "2")]
    pub kitchens: ::prost::alloc::vec::Vec<KitchenSetup>,
}
impl ::prost::Name for SiteSetup {
    const NAME: &'static str = "SiteSetup";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.SiteSetup".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.SiteSetup".into()
    }
}
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KitchenSetup {
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<Kitchen>,
    #[prost(message, repeated, tag = "2")]
    pub stations: ::prost::alloc::vec::Vec<Station>,
}
impl ::prost::Name for KitchenSetup {
    const NAME: &'static str = "KitchenSetup";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.KitchenSetup".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.KitchenSetup".into()
    }
}
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VendorSetup {
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<super::super::vendors::v1::Vendor>,
    #[prost(message, repeated, tag = "2")]
    pub brands: ::prost::alloc::vec::Vec<Brand>,
}
impl ::prost::Name for VendorSetup {
    const NAME: &'static str = "VendorSetup";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.VendorSetup".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.VendorSetup".into()
    }
}
/// Physical cooking spaces within locations, operated by vendors
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Kitchen {
    /// Unique identifier for the kitchen
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Name of the kitchen
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for Kitchen {
    const NAME: &'static str = "Kitchen";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.Kitchen".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.Kitchen".into()
    }
}
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Station {
    /// Unique identifier for the station
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Name of the station
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Type of station
    #[prost(enumeration = "KitchenStation", tag = "3")]
    pub station_type: i32,
}
impl ::prost::Name for Station {
    const NAME: &'static str = "Station";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.Station".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.Station".into()
    }
}
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ingredient {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub price: f64,
    #[prost(string, optional, tag = "5")]
    pub image_url: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for Ingredient {
    const NAME: &'static str = "Ingredient";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.Ingredient".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.Ingredient".into()
    }
}
/// Distinct restaurant brands
///
/// Brands are owned by vendors and operate in specific kitchens
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Brand {
    /// unique identifier for the brand
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub category: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub items: ::prost::alloc::vec::Vec<MenuItem>,
}
impl ::prost::Name for Brand {
    const NAME: &'static str = "Brand";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.Brand".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.Brand".into()
    }
}
/// Menu items are individual dishes within a menu
///
/// Individual food/drink products with details like price, description, and images
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MenuItem {
    /// Unique identifier for the menu item
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Name of the menu item
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// description of the menu item
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Price of the menu item in USD
    #[prost(double, tag = "4")]
    pub price: f64,
    /// URL to an image representing the menu item
    #[prost(string, optional, tag = "5")]
    pub image_url: ::core::option::Option<::prost::alloc::string::String>,
    /// Ingredients required to prepare the menu item
    #[prost(message, repeated, tag = "6")]
    pub ingredients: ::prost::alloc::vec::Vec<IngredientQuantity>,
    /// Instructions required to prepare the menu item
    #[prost(message, repeated, tag = "7")]
    pub instructions: ::prost::alloc::vec::Vec<Instruction>,
}
impl ::prost::Name for MenuItem {
    const NAME: &'static str = "MenuItem";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.MenuItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.MenuItem".into()
    }
}
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngredientQuantity {
    #[prost(string, tag = "1")]
    pub ingredient_ref: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub quantity: ::prost::alloc::string::String,
}
impl ::prost::Name for IngredientQuantity {
    const NAME: &'static str = "IngredientQuantity";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.IngredientQuantity".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.IngredientQuantity".into()
    }
}
/// An instruction describes a step in the preparation of a menu item.
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Instruction {
    /// Name of the step
    #[prost(string, tag = "1")]
    pub step: ::prost::alloc::string::String,
    /// Free text description on how to perform the step
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// The kitchen asset required to perform the step
    #[prost(enumeration = "KitchenStation", tag = "3")]
    pub required_station: i32,
    /// Estimated duration to perform the step
    #[prost(uint32, tag = "4")]
    pub expected_duration: u32,
}
impl ::prost::Name for Instruction {
    const NAME: &'static str = "Instruction";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.Instruction".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.Instruction".into()
    }
}
#[cfg_attr(feature = "python", ::pyo3::pyclass)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KitchenStation {
    Unspecified = 0,
    Workstation = 1,
    Stove = 2,
    Oven = 3,
}
impl KitchenStation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            KitchenStation::Unspecified => "KITCHEN_STATION_UNSPECIFIED",
            KitchenStation::Workstation => "KITCHEN_STATION_WORKSTATION",
            KitchenStation::Stove => "KITCHEN_STATION_STOVE",
            KitchenStation::Oven => "KITCHEN_STATION_OVEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KITCHEN_STATION_UNSPECIFIED" => Some(Self::Unspecified),
            "KITCHEN_STATION_WORKSTATION" => Some(Self::Workstation),
            "KITCHEN_STATION_STOVE" => Some(Self::Stove),
            "KITCHEN_STATION_OVEN" => Some(Self::Oven),
            _ => None,
        }
    }
}
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSitesRequest {
    /// The maximum number of results per page that should be returned.
    #[prost(int32, optional, tag = "2")]
    pub max_results: ::core::option::Option<i32>,
    /// Opaque pagination token to go to next page based on previous query.
    #[prost(string, optional, tag = "3")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for ListSitesRequest {
    const NAME: &'static str = "ListSitesRequest";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.ListSitesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.ListSitesRequest".into()
    }
}
/// List catalogs response.
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSitesResponse {
    /// The sites returned.
    #[prost(message, repeated, tag = "1")]
    pub sites: ::prost::alloc::vec::Vec<Site>,
    /// The next_page_token value to include in the next List request.
    #[prost(string, optional, tag = "2")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for ListSitesResponse {
    const NAME: &'static str = "ListSitesResponse";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.ListSitesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.ListSitesResponse".into()
    }
}
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSiteRequest {
    /// Name of the site.
    ///
    /// The name must be unique amon all sites.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Latitude coordinate of the site's location.
    #[prost(double, tag = "2")]
    pub latitude: f64,
    /// Longitude coordinate of the site's location.
    #[prost(double, tag = "3")]
    pub longitude: f64,
}
impl ::prost::Name for CreateSiteRequest {
    const NAME: &'static str = "CreateSiteRequest";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.CreateSiteRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.CreateSiteRequest".into()
    }
}
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSiteRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetSiteRequest {
    const NAME: &'static str = "GetSiteRequest";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.GetSiteRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.GetSiteRequest".into()
    }
}
#[cfg_attr(feature = "python", ::pyo3::pyclass(get_all, set_all))]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSiteRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteSiteRequest {
    const NAME: &'static str = "DeleteSiteRequest";
    const PACKAGE: &'static str = "caspers.core.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "caspers.core.v1.DeleteSiteRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/caspers.core.v1.DeleteSiteRequest".into()
    }
}
include!("caspers.core.v1.serde.rs");
// @@protoc_insertion_point(module)
