use std::collections::{HashMap, VecDeque};

use arrow::array::AsArray;
use counter::Counter;
use h3o::Resolution;
use itertools::Itertools as _;
use tracing::{Level, Span, field, instrument};
use uuid::Uuid;

use super::kitchen::{KitchenRunner, KitchenStats};
use crate::simulation::EventPayload;
use crate::state::{EntityView, OrderLineStatus, OrderStatus, PersonRole, PersonStatus, State};
use crate::{Error, OrderUpdatedPayload, Result};
use crate::{SimulationContext, idents::*};

#[derive(Clone)]
pub struct OrderLine {
    pub(crate) id: OrderLineId,
    pub(crate) order_id: OrderId,
    pub(crate) item: (BrandId, MenuItemId),
}

struct OrderRouter<'a> {
    kitchens: &'a mut HashMap<KitchenId, KitchenRunner>,
    brand_to_kitchens: HashMap<BrandId, Vec<KitchenId>>,
    submit_counter: Counter<BrandId>,
}

impl<'a> OrderRouter<'a> {
    fn new(kitchens: &'a mut HashMap<KitchenId, KitchenRunner>) -> Self {
        let brand_to_kitchens = kitchens
            .iter()
            .flat_map(|(id, kitchen)| kitchen.accepted_brands().iter().map(|brand| (*brand, *id)))
            .into_group_map();
        OrderRouter {
            kitchens,
            brand_to_kitchens,
            submit_counter: Counter::new(),
        }
    }

    pub fn route_order_line(&mut self, order_line: OrderLine) -> Vec<EventPayload> {
        let mut events = Vec::new();

        let brand = order_line.item.0;
        self.submit_counter[&brand] += 1;
        let kitchen_ids = &self.brand_to_kitchens[&brand];
        let index = self.submit_counter[&brand] % kitchen_ids.len();
        if let Some(kitchen) = self.kitchens.get_mut(&kitchen_ids[index]) {
            events.push(EventPayload::order_line_updated(
                order_line.id,
                OrderLineStatus::Assigned,
                Some(*kitchen.id()),
                None,
            ));
            kitchen.queue_order_line(order_line);
        } else {
            tracing::error!("No kitchen available for brand {:?}", brand);
        }

        events
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct SiteStats {
    pub queue_length: usize,
}

impl std::ops::Add for SiteStats {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        Self {
            queue_length: self.queue_length + other.queue_length,
        }
    }
}

pub struct SiteRunner {
    id: SiteId,

    /// Kitchens available at this location.
    kitchens: HashMap<KitchenId, KitchenRunner>,

    // order_data: OrderData,
    /// Orders waiting to be processed at this location.
    order_queue: VecDeque<OrderId>,

    /// Order lines currently being processed at this location.
    order_lines: HashMap<OrderLineId, OrderLine>,
}

impl SiteRunner {
    #[instrument(
        name = "step_site",
        level = Level::TRACE,
        skip(self, ctx, events, state),
        fields(
            caspers.site_id = self.id.to_string(),
            caspers.orders_created = field::Empty,
            caspers.orders_picked_up = field::Empty,
        )
    )]
    pub(crate) async fn step(
        &mut self,
        ctx: &SimulationContext,
        events: &[EventPayload],
        state: &State,
    ) -> Result<Vec<EventPayload>> {
        // let site = ctx.objects().site(&self.id)?;
        let span = Span::current();

        let new_orders = events
            .iter()
            .filter_map(|event| match event {
                EventPayload::OrderUpdated(
                    payload @ OrderUpdatedPayload {
                        status: OrderStatus::Submitted,
                        ..
                    },
                ) => Some(payload.order_id),
                _ => None,
            })
            .collect_vec();

        span.record("caspers.orders_created", new_orders.len());

        self.receive_orders(&new_orders, state)?;

        // A buffer for all event data generated by this step
        let mut events = Vec::new();

        // Route orders to kitchens and process completed order lines
        events.extend(self.process_orders(state)?);

        // Handle order pickup
        events.extend(self.handle_order_pickup(ctx, state).await?);

        Ok(events)
    }
}

impl SiteRunner {
    pub(crate) fn try_new(id: SiteId, state: &State) -> Result<Self> {
        let kitchens = state
            .objects()
            .kitchens(&id)?
            .map_ok(|(id, brands)| Ok::<_, Error>((id, KitchenRunner::try_new(id, brands, state)?)))
            .flatten()
            .try_collect()?;

        Ok(SiteRunner {
            id,
            kitchens,
            order_queue: VecDeque::new(),
            order_lines: HashMap::new(),
        })
    }

    pub(crate) fn id(&self) -> &SiteId {
        &self.id
    }

    /// Receive new orders from the state and queue them for processing.
    fn receive_orders(&mut self, orders: &[OrderId], ctx: &State) -> Result<()> {
        let orders = orders
            .iter()
            .flat_map(|order_id| ctx.orders().order(order_id));
        for order in orders {
            for line in order.lines() {
                self.order_lines.insert(
                    *line.id(),
                    OrderLine {
                        id: *line.id(),
                        order_id: *order.id(),
                        item: (line.brand_id().try_into()?, line.menu_item_id().try_into()?),
                    },
                );
            }
            self.order_queue.push_back(*order.id());
        }
        Ok(())
    }

    fn process_orders(&mut self, ctx: &State) -> Result<Vec<EventPayload>> {
        let mut events = Vec::new();

        // Route order lines to kitchens for processing.
        // A single order may contain lines from multiple brands,
        // so we need to route each line separately to a kitchen that can handle it.
        let mut router = OrderRouter::new(&mut self.kitchens);
        while let Some(order_id) = self.order_queue.pop_front() {
            if let Some(order) = ctx.orders().order(&order_id) {
                for line in order.lines() {
                    if let Some(line) = self.order_lines.get(line.id()) {
                        events.extend(router.route_order_line(line.clone()));
                    }
                }
            }
        }

        // Advance kitchens and collect completed order lines
        for kitchen in self.kitchens.values_mut() {
            events.extend(kitchen.step(ctx)?);
            events.extend(kitchen.take_completed().into_iter().map(|(_, id)| {
                EventPayload::order_line_updated(
                    id,
                    OrderLineStatus::Ready,
                    Some(*kitchen.id()),
                    None,
                )
            }));
        }

        Ok(events)
    }

    pub fn stats(&self) -> SiteStats {
        SiteStats {
            queue_length: self.order_queue.len(),
        }
    }

    pub fn kitchen_stats(&self) -> impl Iterator<Item = KitchenStats> {
        self.kitchens.values().map(|kitchen| kitchen.stats())
    }

    pub fn total_kitchen_stats(&self) -> KitchenStats {
        self.kitchen_stats()
            .fold(KitchenStats::default(), |acc, stats| acc + stats)
    }

    async fn handle_order_pickup(
        &mut self,
        ctx: &SimulationContext,
        state: &State,
    ) -> Result<Vec<EventPayload>> {
        let mut events = Vec::new();

        let site_location = state.objects().site(&self.id)?.properties()?.lat_lng()?;
        let planner = state
            .trip_planner(&self.id)
            .ok_or(Error::invalid_data("no planner registered for site"))?;

        let Some(site_location_node) = planner.nearest_node(&site_location) else {
            tracing::error!("No node found for site location");
            return Err(Error::invalid_geometry("No node found for site location"));
        };

        let orders = state
            .orders()
            .orders_with_status(&self.id, &OrderStatus::Ready)
            .collect_vec();

        let couriers = state
            .population()
            .idle_people_in_cell(
                ctx,
                site_location.to_cell(Resolution::Eight),
                &PersonRole::Courier,
            )
            .await?
            .limit(0, Some(orders.len()))?
            .select_columns(&["id"])?
            .collect()
            .await?;
        let couriers_iter = couriers.into_iter().flat_map(|courier| {
            courier
                .column(0)
                .as_fixed_size_binary()
                .iter()
                .flat_map(|maybe_id| maybe_id.and_then(|id| Uuid::from_slice(id).ok()))
                .map(PersonId::from)
                .collect_vec()
        });

        let mut router = planner.get_router();

        let order_queue = orders.into_iter().zip(couriers_iter);
        for (order, courier) in order_queue {
            let destination = order.destination()?;

            // Generate the delivery route for the courier
            let Some(destination_node) = planner.nearest_node(&destination) else {
                tracing::error!(target: "site-agent", "Failed to find a node for order {:?}", order.id());
                events.push(EventPayload::order_failed(*order.id(), None));
                continue;
            };
            let Some(journey) = planner.plan(&mut router, site_location_node, destination_node)
            else {
                tracing::error!("Failed to find a route for order {:?}", order.id());
                events.push(EventPayload::order_failed(*order.id(), None));
                continue;
            };

            events.push(EventPayload::order_updated(
                *order.id(),
                OrderStatus::PickedUp,
                Some(courier),
            ));

            events.push(EventPayload::person_updated(
                courier,
                PersonStatus::Delivering(*order.id(), journey),
            ));
        }

        Ok(events)
    }
}
